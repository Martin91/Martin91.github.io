<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 属性方法 | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/shu-xing-fang-fa/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2017-10-19T07:58:44+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[属性方法]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/12/shu-xing-fang-fa/"/>
    <updated>2014-03-12T20:58:17+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/12/shu-xing-fang-fa</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_attribute_methods/">Reading Rails &ndash; Attribute Methods</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>在我们<a href="/blog/2014/03/07/zhui-zong-bian-geng/">上一篇的探讨</a>中，我们已经看到了Rails在跟踪属性变更中使用到的属性方法（attribute methods）。有三种类型的属性方法：前缀式（prefix）、后缀式（suffix）以及固定词缀式（ affix）。为了表述简洁，我们将只关注类似<code>attribute_method_suffix</code>这样的后缀式属性方法，并且特别关注它是如何帮助我们实现类似<code>name</code>这样的模型属性以及对应生成的类似<code>name_changed?</code>这样的方法的。</p>

<!-- More -->


<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>声明（Declarations）</h3>

<p>属性方法是Rails中众多使用了元编程技术的案例之一。在元编程中，我们编写可以编写代码的代码。举例来说，<code>attribute_method_suffix</code>后缀式方法是一个为每个属性都定义了一个helper方法的方法。在<a href="/blog/2014/03/07/zhui-zong-bian-geng/">之前的讨论</a>中，ActiveModel使用这种方式为您的每一个属性都定义了一个<code>_changed?</code>方法(<strong>提示</strong>： 命令行中键入<code>qw activemodel</code>查看代码)：
```ruby
module Dirty
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods</p>

<p>  included do</p>

<pre><code>attribute_method_suffix '_changed?', '_change', '_will_change!', '_was'
#...
</code></pre>

<p><code>
让我们打开ActiveModel库中的`attribute_methods.rb`文件，并且看一下到底发生了什么事情。
</code>ruby
def attribute_method_suffix(*suffixes)
  self.attribute_method_matchers += suffixes.map! do |suffix|</p>

<pre><code>AttributeMethodMatcher.new suffix: suffix
</code></pre>

<p>  end
  #&hellip;
end
```</p>

<p>当你调用<code>attribute_method_suffix</code>方法的时候，每一个后缀都通过<code>map!</code>方法转换为一个<code>AttributeMethodMatcher</code>对象。这些对象会被存储在<code>attribute_method_matchers</code>中。如果你重新看一下这个module的顶部，你会发现<code>attribute_method_matchers</code>是在每一个包含此module的类中使用<code>class_attribute</code>定义的方法：
```ruby
module AttributeMethods
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>class_attribute :attribute_aliases,
                :attribute_method_matchers,
                instance_writer: false
#...
</code></pre>

<p>```</p>

<p><code>class_attribute</code>方法帮助你在类上定义属性。你可以这样在你自己的代码中这样使用：
```ruby
class Person
  class_attribute :database
  #&hellip;
end</p>

<p>class Employee &lt; Person
end</p>

<p>Person.database = Sql.new(:host=>&lsquo;localhost&rsquo;)
Employee.database #=> &lt;Sql:host=&lsquo;localhost&rsquo;>
```</p>

<p>Ruby中并没有<code>class_attribute</code>的内置实现，它是在ActiveSupport(<strong>提示</strong>:命令行中键入<code>qw activesupport</code>查看代码)中定义的方法。如果你对此比较好奇，可以简单看下<code>attribute.rb</code></p>

<p>现在我们来看一下<code>AttributeMethodMatcher</code>。
```ruby
class AttributeMethodMatcher #:nodoc:
  attr_reader :prefix, :suffix, :method_missing_target</p>

<p>  def initialize(options = {})</p>

<pre><code>#...
@prefix, @suffix = options.fetch(:prefix, ''), options.fetch(:suffix, '')
@regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
@method_missing_target = "#{@prefix}attribute#{@suffix}"
@method_name = "#{prefix}%s#{suffix}"
</code></pre>

<p>  end
<code>
代码中的`prefix`以及`suffix`是通过`Hash#fetch`方法提取出来的。这会返回一个对应键的值，或者是一个默认值。如果调用方法的时候没有提供默认值，`Hash#fetch`方法将会抛出一个异常，提示指定的键不存在。对于options的处理来说是一种不错的模式，特别是对于boolean型数据来说：
</code>ruby
options = {:name => &ldquo;Mortimer&rdquo;, :imaginary => false}</p>

<h1>Don&rsquo;t do this:</h1>

<p>options[:imaginary] || true     #=> true</p>

<h1>Do this:</h1>

<p>options.fetch(:imaginary, true) #=> false
```</p>

<p>对于我们的<code>attribute_method_suffix</code>其中的<code>'_changed'</code>示例来说，<code>AttributeMethodMatcher</code>将会有如下的实例变量：
<code>ruby
@prefix                #=&gt; ""
@suffix                #=&gt; "_changed?"
@regex                 #=&gt; /^(?:)(.*)(?:_changed\?)$/
@method_missing_target #=&gt; "attribute_changed?"
@method_name           #=&gt; "%s_changed?"
</code></p>

<p>你一定想知道<code>%s_changed</code>中的<code>%s</code>是用来干什么的吧？这是一个格式化字符串（format string）。你可以使用<code>sprintf</code>方法对它插入值，或者使用缩写（shortcut）<code>%</code>：
<code>ruby
sprintf("%s_changed?", "name") #=&gt; "named_changed?"
"%s_changed?" % "age"          #=&gt; "age_changed?"
</code></p>

<p>第二个比较有趣的地方就是正则表达式创建的方式。请留意创建<code>@regex</code>变量时<code>Regexp.escape</code>的用法。如果后缀没有被escape，则正则表达式中带有特殊含义的符号将会被错误解释(misinterpreted)：
```ruby</p>

<h1>Don&rsquo;t do this!</h1>

<p>regex = /^(?:#{@prefix})(.<em>)(?:#{@suffix})$/ #=> /^(?:)(.</em>)(?:_changed?)$/
regex.match(&ldquo;name_changed?&rdquo;)                 #=> nil
regex.match(&ldquo;name_change&rdquo;)                   #=> #<MatchData "name_change" 1:"name"></p>

<h1>Do this:</h1>

<p>@regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
regex.match(&ldquo;name_changed?&rdquo;)                 #=> #<MatchData "name_changed?" 1:"name">
regex.match(&ldquo;name_change&rdquo;)                   #=> nil
```</p>

<p>请仔细记住<code>regex</code>以及<code>method_name</code>，它们可以用来匹配和生成属性方法，我们在后面还会继续用到它们。</p>

<p>我们现在已经搞明白了属性方法是如何声明的，但是实际中，Rails又是如何使用它们的呢？</p>

<h3>通过Method Missing调用（Invocation With Method Missing）</h3>

<p>当我们调用了一个未定义的方法时，Rails将会在抛出异常之前调用对象的<code>method_missing</code>方法。让我们看看Rails是如何利用这个技巧调用属性方法的：
```ruby
def method_missing(method, *args, &amp;block)
  if respond_to_without_attributes?(method, true)</p>

<pre><code>super
</code></pre>

<p>  else</p>

<pre><code>match = match_attribute_method?(method.to_s)
match ? attribute_missing(match, *args, &amp;block) : super
</code></pre>

<p>  end
end
```</p>

<p>传给<code>method_missing</code>方法的第一个参数是一个用symbol类型表示的方法名，比如，我们的<code>:name_changed?</code>。<code>*args</code>是（未定义的）方法被调用时传入的所有参数，<code>&amp;block</code>是一个可选的代码块。Rails首先通过调用<code>respond_to_without_attributes</code>方法检查是否有别的方法可以对应这次调用。如果别的方法可以处理这次调用，则通过<code>super</code>方法转移控制权。如果找不到别的方法可以处理当前的调用，ActiveModel则会通过<code>match_attribute_method?</code>方法检查当前调用的方法是否是一个属性方法。如果是，它则会接着调用<code>attribute_missing</code>方法。</p>

<p><code>match_attribute_method</code>方法利用了之前声明过的<code>AttributeMethodMatcher</code>对象：
<code>ruby
def match_attribute_method?(method_name)
  match = self.class.send(:attribute_method_matcher, method_name)
  match if match &amp;&amp; attribute_method?(match.attr_name)
end
</code></p>

<p>在这个方法里边发生了两件事。第一，Rails查找到了一个匹配器(matcher)，并且检查这是否真的是一个属性。说实话，我自己也是比较迷惑，为什么<code>match_attribute_method?</code>方法调用的是<code>self.class.send(:attribute_method_matcher, method_name)</code>，而不是<code>self.attribute_method_matcher(method_name)</code>，但是我们还是可以假设它们的效果是一样的。</p>

<p>如果我们再接着看<code>attribute_method_matcher</code>，就会发现它的最核心的代码仅仅只是扫描匹配了<code>AttributeMethodMatcher</code>实例，它所做的事就是对比对象本身的正则表达式与当前的方法名：
<code>ruby
def attribute_method_matcher(method_name)
  #...
  attribute_method_matchers.detect { |method| method.match(method_name) }
  #...
end
</code></p>

<p>如果Rails找到了匹配当前调用的方法的属性，那么接下来所有参数都会被传递给<code>attribute_missing</code>方法：
<code>ruby
def attribute_missing(match, *args, &amp;block)
  __send__(match.target, match.attr_name, *args, &amp;block)
end
</code></p>

<p>这个方法将匹配到的属性名以及传入的任意参数或者代码块代理给了<code>match.target</code>。回头看下我们的实例变量，<code>match.target</code>将会是<code>attribute_changed?</code>，而且<code>match.attr_name</code>则是"name"。<code>__send__</code>方法将会调用<code>attribute_changed?</code>方法，或者是你定义的任意一个特殊的属性方法。</p>

<h3>元编程（Metaprogramming）</h3>

<p>有很多的方式可以对一个方法的调用进行分发（dispatch），如果这个方法经常被调用，那么实现一个<code>name_changed?</code>方法将会更为有效。Rails通过<code>define_attribute_methods</code>方法做到了对这类属性方法的自动定义：
```ruby
def define_attribute_methods(*attr_names)
  attr_names.flatten.each { |attr_name| define_attribute_method(attr_name) }
end</p>

<p>def define_attribute_method(attr_name)
  attribute_method_matchers.each do |matcher|</p>

<pre><code>method_name = matcher.method_name(attr_name)

define_proxy_call true,
                  generated_attribute_methods,
                  method_name,
                  matcher.method_missing_target,
                  attr_name.to_s
</code></pre>

<p>  end
end
```</p>

<p><code>matcher.method_name</code>使用了我们前面见到过的格式化字符串，并且插入了<code>attr_name</code>。在我们的例子中，<code>"%s_changed?"</code>变成了<code>"name_changed?"</code>。现在我们我们准备好了了解在<code>define_proxy_call</code>中的元编程。下面是这个方法被删掉了一些特殊场景下的代码的版本，你可以在阅读完这篇文章后自己去了解更多的代码。
```ruby
def define_proxy_call(include_private, mod, name, send, <em>extra)
  defn = &ldquo;def #{name}(</em>args)&rdquo;
  extra = (extra.map!(&amp;:inspect) &lt;&lt; &ldquo;*args&rdquo;).join(&ldquo;, &rdquo;)
  target = &ldquo;#{send}(#{extra})&rdquo;</p>

<p>  mod.module_eval &lt;&lt;-RUBY, <strong>FILE</strong>, <strong>LINE</strong> + 1</p>

<pre><code>#{defn}
  #{target}
end
</code></pre>

<p>  RUBY
end
```</p>

<p>这里为我们定义了一个新的方法。<code>name</code>就是正要被定义的方法名，而<code>send</code>则是处理器(handler)，另外的<code>extra</code>是属性名。<code>mod</code>参数是一个Rails用<code>generated_attribute_methods</code>方法生成的特殊的模块（module），它被嵌入（mixin）到我们的类中。现在让我们多看一下<code>module_eval</code>方法。这里有三件有趣的事情发生了。</p>

<p>第一件事就是<a href="http://blog.jayfields.com/2006/12/ruby-multiline-strings-here-doc-or.html">HEREDOC</a>被用作一个参数传给了一个方法。这是有点难懂的，但是对某些场景却是非常有用的。举个例子，想象我们在一个服务器响应(response)中有一个方法要用来嵌入Javascript代码：
<code>ruby
include_js(&lt;&lt;-JS, :minify =&gt; true)
  $('#logo').show();
  App.refresh();
JS
</code></p>

<p>这将会把字符串<code>"$('#logo').show(); App.refresh();"</code>作为调用<code>include_js</code>时传入的第一个参数，而<code>:minify =&gt; true</code>作为第二个参数。在Ruby中需要生成代码时，这是一个非常有用的技巧。值得高兴的是，诸如<a href="https://github.com/textmate/textmate">TextMate</a>这类编辑器都能够识别这个模式，并且正确地高亮显示字符串。即使你并不需要生成代码，HEREDOC对于多行的字符串也是比较有用的。</p>

<p>现在我们就知道了<code>&lt;&lt;-RUBY</code>做了些什么事，但是<code>__FILE__</code>以及<code>__LINE__ + 1</code>呢？<code>__FILE__</code>返回了当前文件的（相对）路径，而<code>__LINE__</code>返回了当前代码的行号。<code>module_eval</code>接收这些参数，并通过这些参数决定新的代码定义在文件中“看起来”的位置。在对于栈跟踪（stack traces）来说是特别有用的。</p>

<p>最后，让我们看一些<code>module_eval</code>中实际执行的代码。我们可以把值替换成我们的<code>name_changed?</code>：
```ruby
mod.module_eval &lt;&lt;-RUBY, <strong>FILE</strong>, <strong>LINE</strong> + 1
  def name_changed?(*args)</p>

<pre><code>attribute_changed?("name", *args)
</code></pre>

<p>  end
RUBY
<code>``
现在</code>name_changed?<code>就是一个真实的方法了，比起依赖于</code>method_missing`方法的实现，这种方法的开销要小得多。</p>

<h3>总结（Recap）</h3>

<p>我们发现了调用<code>attribute_method_suffix</code>方法会保存一个配置好的对象，这个对象用于Rails中两种元编程方法中的一种。不考虑是否使用了<code>method_missing</code>，或者通过<code>module_eval</code>定义了新的方法，方法的调用最后总会被传递到诸如<code>attribute_changed?(attr)</code>这样的方法上。</p>

<p>走过这次比较宽泛的旅途，我们也收获了一些有用的技巧：</p>

<ul>
<li>你必须使用<code>Hash#fetch</code>从options中读取参数，特别是对于boolean类型参数来说。</li>
<li>诸如<code>"%s_changed"</code>这样的格式化字符串，可以被用于简单的模板。</li>
<li>可以使用<code>Regexp.escape</code>escape正则表达式。</li>
<li>当你试图调用一个未定义的方法时，Ruby会调用<code>method_missing</code>方法。</li>
<li>HEREDOCs可以用在方法参数中，也可以用来定义多行的字符串。</li>
<li><code>__FILE__</code>以及<code>__LINE__</code>指向当前的文件以及行号。</li>
<li>你可以使用<code>module_eval</code>动态生成代码。</li>
</ul>


<p>坚持浏览Rails的源代码吧，你总会发现你原本不知道的宝藏！</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>《解读Rails》中的文章。</p>
]]></content>
  </entry>
  
</feed>
