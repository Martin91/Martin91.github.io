<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2017-10-09T21:40:35+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解读Rails - 适配器模式]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi/"/>
    <updated>2014-03-03T13:40:03+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>本文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_the_adapter_pattern/?utm_source=rubyweekly&amp;utm_medium=email">Reading Rails &ndash; The Adapter Pattern</a>，限于本人水平有限，翻译不当之处，敬请指教！</p>

<p>今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是<a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式（Adapter Pattern）</a>。从一定的意义上来说，这次的探索并不全面，但是我希望能够突出一些实际的例子。</p>

<!-- MORE -->


<p>为了跟随本文的步骤，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开相关的代码库，或者直接在<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github</a>上查看这些代码。</p>

<h3>适配器模式</h3>

<p><a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式</a>可以用于对不同的接口进行包装以及提供统一的接口，或者是让某一个对象看起来像是另一个类型的对象。在静态类型的编程语言里，我们经常使用它去满足类型系统的特点，但是在类似Ruby这样的弱类型编程语言里，我们并不需要这么做。尽管如此，它对于我们来说还是有很多意义的。</p>

<p>当使用第三方类或者库的时候，我们经常从这个例子开始（start out fine）：
<code>ruby
def find_nearest_restaurant(locator)
  locator.nearest(:restaurant, self.lat, self.lon)
end
</code>
我们假设有一个针对<code>locator</code>的接口，但是如果我们想要<code>find_nearest_restaurant</code>能够支持另一个库呢？这个时候我们可能就会去尝试添加新的特殊的场景的处理：
``` ruby
def find_nearest_restaurant(locator)
  if locator.is_a? GeoFish</p>

<pre><code>locator.nearest(:restaurant, self.lat, self.lon)
</code></pre>

<p>  elsif locator.is_a? ActsAsFound</p>

<pre><code>locator.find_food(:lat =&gt; self.lat, :lon =&gt; self.lon)
</code></pre>

<p>  else</p>

<pre><code>raise NotImplementedError, "#{locator.class.name} is not supported."
</code></pre>

<p>  end
end
<code>``
这是一个比较务实的解决方案。或许我们也不再需要考虑去支持另一个库了。也或许</code>find_nearest_restaurant<code>就是我们使用</code>locator`的唯一场景。</p>

<p>那假如你真的需要去支持一个新的<code>locator</code>，那又会是怎么样的呢？那就是你有三个特定的场景。再假如你需要实现<code>find_nearest_hospital</code>方法呢？这样你就需要在维护这三种特定的场景时去兼顾两个不同的地方。当你觉得这种解决方案不再可行的时候，你就需要考虑适配器模式了。</p>

<p>在这个例子中，我们可以为<code>GeoFish</code>以及<code>ActsAsFound</code>编写适配器，这样的话，在我们的其他代码中，我们就不需要了解我们当前正在使用的是哪个库了：
``` ruby
def find_nearest_hospital(locator)
  locator.find :type => :hospital,</p>

<pre><code>           :lat =&gt; self.lat,
           :lon =&gt; self.lon
</code></pre>

<p>end</p>

<p>locator = GeoFishAdapter.new(geo_fish_locator)
find_nearest_hospital(locator)
```
特意假设的例子就到此为止，接下来让我们看看真实的代码。</p>

<h3>MultiJSON</h3>

<p><code>ActiveSupport</code>在做JSON格式的解码时，用到的是<code>MultiJSON</code>，这是一个针对JSON库的适配器。每一个库都能够解析JSON，但是做法却不尽相同。让我们分别看看针对<a href="https://github.com/ohler55/oj">oj</a>和<a href="https://github.com/brianmario/yajl-ruby">yajl</a>的适配器。
(<strong>提示</strong>: 可在命令行中输入<code>qw multi_json</code>查看源码。)
``` ruby
module MultiJson
  module Adapters</p>

<pre><code>class Oj &lt; Adapter
  #...
  def load(string, options={})
    options[:symbol_keys] = options.delete(:symbolize_keys)
    ::Oj.load(string, options)
  end
  #...
</code></pre>

<p><code>
Oj的适配器修改了`options`哈希表，使用`Hash#delete`将`:symbolize_keys`项转换为Oj的`:symbol_keys`项：
</code> ruby
options = {:symbolize_keys => true}
options[:symbol_keys] = options.delete(:symbolize_keys) # => true
options                                                 # => {:symbol_keys=>true}
<code>``
接下来MultiJSON调用了</code>::Oj.load(string, options)<code>。MultiJSON适配后的API跟Oj原有的API非常相似，在此不必赘述。不过你是否注意到，Oj是如何引用的呢？</code>::Oj<code>引用了顶层的</code>Oj<code>类，而不是</code>MultiJson::Adapters::Oj`。</p>

<p>现在让我们看看MultiJSON又是如何适配Yajl库的：
``` ruby
module MultiJson
  module Adapters</p>

<pre><code>class Yajl &lt; Adapter
  #...
  def load(string, options={})
    ::Yajl::Parser.new(:symbolize_keys =&gt; options[:symbolize_keys]).parse(string)
  end
  #...
</code></pre>

<p><code>``
这个适配器从不同的方式实现了</code>load<code>方法。Yajl的方式是先创建一个解析器的实力，然后将传入的字符串</code>string<code>作为参数调用</code>Yajl::Parser#parse<code>方法。在</code>options<code>哈希表上的处理也略有不同。只有</code>:symbolize_keys`项被传递给了Yajl。</p>

<p>这些JSON的适配器看似微不足道，但是他们却可以让你随心所欲地在不同的库之间进行切换，而不需要在每一个解析JSON的地方更新代码。</p>

<h3>ActiveRecord</h3>

<p>很多JSON库往往都遵从相似的模式，这让适配工作变得相当轻松。但是如果你是在处理一些更加复杂的情况时，结果会是怎样？ActiveRecord包含了针对不同数据库的适配器。尽管PostgreSQL和MySQL都是SQL数据库，但是他们之间还是有很多不同之处，而ActiveRecord通过使用适配器模式屏蔽了这些不同。(<strong>提示</strong>: 命令行中输入<code>qw activerecord</code>查看ActiveRecord的代码)</p>

<p>打开ActiveRecord代码库中的<code>lib/connection_adapters</code>目录，里边会有针对PostgreSQL,MySQL以及SQLite的适配器。除此之外，还有一个名为<code>AbstractAdapter</code>的适配器，它作为每一个具体的适配器的基类。<code>AbstractAdapter</code>实现了在大部分数据库中常见的功能，这些功能在其子类比如<code>PostgreSQLAdapter</code>以及<code>AbstractMysqlAdapter</code>中被重新定制，而其中<code>AbstractMysqlAdapter</code>则是另外两个不同的MySQL适配器——MysqlAdapter以及Mysql2Adapter——的父类。让我们通过一些真实世界中的例子来看看他们是如何一起工作的。</p>

<p>PostgreSQL和MySQL在SQL方言的实现稍有不同。查询语句<code>SELECT * FROM users</code>在这两个数据库都可以正常执行，但是它们在一些类型的处理上会稍显不同。在MySQL和PostgreSQL中，时间格式就不尽相同。其中，PostgreSQL支持微秒级别的时间，而MySQL只是到了最近的一个稳定发布的版本中才支持。那这两个适配器又是如何处理这种差异的呢？</p>

<p>ActiveRecord通过被混入到<code>AbstractAdapter</code>的<code>ActiveRecord::ConnectionAdapters::Quoting</code>中的<code>quoted_date</code>引用日期。而<code>AbstractAdapter</code>中的实现仅仅只是格式化了日期：
<code>ruby
def quoted_date(value)
  #...
  value.to_s(:db)
end
</code>
Rails中的ActiveSupport扩展了<code>Time#to_s</code>，使其能够接收一个代表格式名的符号类型参数。<code>:db</code>所代表的格式就是<code>%Y-%m-%d %H:%M:%S</code>：
``` ruby</p>

<h1>Examples of common formats:</h1>

<p>Time.now.to_s(:db)      #=> &ldquo;2014-02-19 06:08:13&rdquo;
Time.now.to_s(:short)   #=> &ldquo;19 Feb 06:08&rdquo;
Time.now.to_s(:rfc822)  #=> &ldquo;Wed, 19 Feb 2014 06:08:13 +0000&rdquo;
<code>
MySQL的适配器都没有重写`quoted_date`方法，它们自然会继承这种行为。另一边，`PostgreSQLAdapter`则对日期的处理做了两个修改：
</code> ruby
def quoted_date(value)
  result = super
  if value.acts_like?(:time) &amp;&amp; value.respond_to?(:usec)</p>

<pre><code>result = "#{result}.#{sprintf("%06d", value.usec)}"
</code></pre>

<p>  end</p>

<p>  if value.year &lt; 0</p>

<pre><code>result = result.sub(/^-/, "") + " BC"
</code></pre>

<p>  end
  result
end
<code>``
它在一开始便调用</code>super<code>方法，所以它也会得到一个类似MySQL中格式化后的日期。接下来，它检测</code>value<code>是否像是一个具体时间。这是一个ActiveSupport中扩展的方法，当一个对象类似</code>Time<code>类型的实例时，它会返回</code>true<code>。这让它更容易表明各种对象已被假设为类似</code>Time<code>的对象。（**提示**: 对</code>acts_like?<code>方法感兴趣？请在命令行中执行</code>qw activesupport<code>，然后阅读</code>core_ext/object/acts_like.rb`）</p>

<p>第二部分的条件检查<code>value</code>是否有用于返回毫秒的<code>usec</code>方法。如果可以求得毫秒数，那么它将通过<code>sprintf</code>方法被追加到<code>result</code>字符串的末尾。跟很多时间格式一样，<code>sprintf</code>也有很多不同的方式用于格式化数字：
<code>ruby
sprintf("%06d", 32) #=&gt; "000032"
sprintf("%6d",  32) #=&gt; "    32"
sprintf("%d",   32) #=&gt; "32"
sprintf("%.2f", 32) #=&gt; "32.00"
</code>
最后，假如日期是一个负数，<code>PostgreSQLAdapter</code>就会通过加上"BC"去重新格式化日期，这是PostgreSQL数据库的实际要求：
<code>ruby
SELECT '2000-01-20'::timestamp;
-- 2000-01-20 00:00:00
SELECT '2000-01-20 BC'::timestamp;
-- 2000-01-20 00:00:00 BC
SELECT '-2000-01-20'::timestamp;
-- ERROR:  time zone displacement out of range: "-2000-01-20"
</code>
这只是ActiveRecord适配多个API时的一个极小的方式，但它却能帮助你免除由于不同数据库的细节所带来的差异和烦恼。</p>

<p>另一个体现SQL数据库的不同点是数据库表被创建的方式。MySQL以及PostgreSQL中对主键的处理各不相同：
``` ruby</p>

<h1>AbstractMysqlAdapter</h1>

<p>NATIVE_DATABASE_TYPES = {
  :primary_key => &ldquo;int(11) DEFAULT NULL auto_increment PRIMARY KEY&rdquo;,
  #&hellip;
}</p>

<h1>PostgreSQLAdapter</h1>

<p>NATIVE_DATABASE_TYPES = {
  primary_key: &ldquo;serial primary key&rdquo;,
  #&hellip;
}
```
这两种适配器都能够明白ActiveRecord中的主键的表示方式，但是它们会在创建新表的时候将此翻译为不同的SQL语句。当你下次在编写一个migration或者执行一个查询的时候，思考一下ActiveRecord的适配器以及它们为你做的所有微小的事情。</p>

<h3>DateTime和Time</h3>

<p>当MultiJson以及ActiveRecord实现了传统的适配器的时候，Ruby的灵活性使得另一种解决方案成为可能。<code>DateTime</code>以及<code>Time</code>都用于表示时间，但是它们在内部的处理上是不同的。虽然有着这些细微的差异，但是它们所暴露出来的API却是极其类似的（<strong>提示</strong>：命令行中执行<code>qw activesupport</code>查看此处相关代码）：
``` ruby
t = Time.now
t.day     #=> 19         (Day of month)
t.wday    #=> 3          (Day of week)
t.usec    #=> 371552     (Microseconds)
t.to_i    #=> 1392871392 (Epoch secconds)</p>

<p>d = DateTime.now
d.day     #=> 19         (Day of month)
d.wday    #=> 3          (Day of week)
d.usec    #=> NoMethodError: undefined method <code>usec'
d.to_i    #=&gt; NoMethodError: undefined method</code>to_i'
<code>
ActiveSupport通过添加缺失的方法来直接修改`DateTime`和`Time`，进而抹平了两者之间的差异。从实例上看，这里就有一个例子演示了ActiveSupport如何定义`DateTime#to_i`：
</code> ruby
class DateTime
  def to_i</p>

<pre><code>seconds_since_unix_epoch.to_i
</code></pre>

<p>  end</p>

<p>  def seconds_since_unix_epoch</p>

<pre><code>(jd - 2440588) * 86400 - offset_in_seconds + seconds_since_midnight
</code></pre>

<p>  end</p>

<p>  def offset_in_seconds</p>

<pre><code>(offset * 86400).to_i
</code></pre>

<p>  end</p>

<p>  def seconds_since_midnight</p>

<pre><code>sec + (min * 60) + (hour * 3600)
</code></pre>

<p>  end
end
<code>``
每一个用于支持的方法，</code>seconds_since_unix_epoch<code>，</code>offset_in_seconds<code>，以及</code>seconds_since_midnight<code>都使用或者扩展了</code>DateTime<code>中已经存在的API去定义与</code>Time`中匹配的方法。</p>

<p>假如说我们前面所看到的适配器是相对于被适配对象的外部适配器，那么我们现在所看到的这个就可以被称之为内部适配器。与外部适配器不同的是，这种方法受限于已有的API，并且可能导致一些麻烦的矛盾问题。举例来说，<code>DateTime</code>和<code>Time</code>在一些特殊的场景下就有可能出现不一样的行为：
<code>ruby
datetime == time #=&gt; true
datetime + 1     #=&gt; 2014-02-26 07:32:39
time + 1         #=&gt; 2014-02-25 07:32:40
</code>
当加上1的时候，<code>DateTime</code>加上了一天，而<code>Time</code>则是加上了一秒。当你需要使用它们的时候，你要记住ActiveSupport基于这些不同，提供了诸如<code>change</code>和<code>Duration</code>等保证一致行为的方法或类。</p>

<p>这是一个好的模式吗？它理所当然是方便的，但是如你刚才所见，你仍旧需要注意其中的一些不同之处。</p>

<h3>总结</h3>

<p>设计模式不是只有Java才需要的。Rails通过使用设计模式以提供用于JSON解析以及数据库维护的统一接口。由于Ruby的灵活性，类似<code>DateTime</code>以及<code>Time</code>这样的类可以被直接地修改而提供相似的接口。Rails的源码就是一个可以让你挖掘真实世界中不同设计模式实例的天堂。</p>

<p>在这次的实践中，我们同时也发掘了一些有趣的代码：</p>

<ul>
<li><code>hash[:foo] = hash.delete(:bar)</code>是一个用于重命名哈希表中某一项的巧妙方法。</li>
<li>调用<code>::ClassName</code>会调用顶层的类。</li>
<li>ActiveSupport为<code>Time</code>、<code>Date</code>以及其他的类添加了一个可选的代表格式的参数<code>format</code>。</li>
<li><code>sprintf</code>可以用于格式化数字。</li>
</ul>


<p>想要探索更多的知识？回去看看MultiJson是如何处理以及解析格式的。仔细阅读你在你的数据库中所使用到的ActiveRecord的适配器的代码。浏览ActiveSupport中用于xml适配器的<code>XmlMini</code>，它跟MultiJson中的JSON适配器是类似的。在这些里面还会有很多可以学习的。</p>

<p>喜欢这篇文章？<br>
<a href="/blog/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读另外8篇</a>“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
</feed>
