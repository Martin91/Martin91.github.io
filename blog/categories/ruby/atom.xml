<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2017-10-15T15:52:54+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[属性方法]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/12/shu-xing-fang-fa/"/>
    <updated>2014-03-12T20:58:17+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/12/shu-xing-fang-fa</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_attribute_methods/">Reading Rails &ndash; Attribute Methods</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>在我们<a href="/blog/2014/03/07/zhui-zong-bian-geng/">上一篇的探讨</a>中，我们已经看到了Rails在跟踪属性变更中使用到的属性方法（attribute methods）。有三种类型的属性方法：前缀式（prefix）、后缀式（suffix）以及固定词缀式（ affix）。为了表述简洁，我们将只关注类似<code>attribute_method_suffix</code>这样的后缀式属性方法，并且特别关注它是如何帮助我们实现类似<code>name</code>这样的模型属性以及对应生成的类似<code>name_changed?</code>这样的方法的。</p>

<!-- More -->


<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>声明（Declarations）</h3>

<p>属性方法是Rails中众多使用了元编程技术的案例之一。在元编程中，我们编写可以编写代码的代码。举例来说，<code>attribute_method_suffix</code>后缀式方法是一个为每个属性都定义了一个helper方法的方法。在<a href="/blog/2014/03/07/zhui-zong-bian-geng/">之前的讨论</a>中，ActiveModel使用这种方式为您的每一个属性都定义了一个<code>_changed?</code>方法(<strong>提示</strong>： 命令行中键入<code>qw activemodel</code>查看代码)：
```ruby
module Dirty
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods</p>

<p>  included do</p>

<pre><code>attribute_method_suffix '_changed?', '_change', '_will_change!', '_was'
#...
</code></pre>

<p><code>
让我们打开ActiveModel库中的`attribute_methods.rb`文件，并且看一下到底发生了什么事情。
</code>ruby
def attribute_method_suffix(*suffixes)
  self.attribute_method_matchers += suffixes.map! do |suffix|</p>

<pre><code>AttributeMethodMatcher.new suffix: suffix
</code></pre>

<p>  end
  #&hellip;
end
```</p>

<p>当你调用<code>attribute_method_suffix</code>方法的时候，每一个后缀都通过<code>map!</code>方法转换为一个<code>AttributeMethodMatcher</code>对象。这些对象会被存储在<code>attribute_method_matchers</code>中。如果你重新看一下这个module的顶部，你会发现<code>attribute_method_matchers</code>是在每一个包含此module的类中使用<code>class_attribute</code>定义的方法：
```ruby
module AttributeMethods
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>class_attribute :attribute_aliases,
                :attribute_method_matchers,
                instance_writer: false
#...
</code></pre>

<p>```</p>

<p><code>class_attribute</code>方法帮助你在类上定义属性。你可以这样在你自己的代码中这样使用：
```ruby
class Person
  class_attribute :database
  #&hellip;
end</p>

<p>class Employee &lt; Person
end</p>

<p>Person.database = Sql.new(:host=>&lsquo;localhost&rsquo;)
Employee.database #=> &lt;Sql:host=&lsquo;localhost&rsquo;>
```</p>

<p>Ruby中并没有<code>class_attribute</code>的内置实现，它是在ActiveSupport(<strong>提示</strong>:命令行中键入<code>qw activesupport</code>查看代码)中定义的方法。如果你对此比较好奇，可以简单看下<code>attribute.rb</code></p>

<p>现在我们来看一下<code>AttributeMethodMatcher</code>。
```ruby
class AttributeMethodMatcher #:nodoc:
  attr_reader :prefix, :suffix, :method_missing_target</p>

<p>  def initialize(options = {})</p>

<pre><code>#...
@prefix, @suffix = options.fetch(:prefix, ''), options.fetch(:suffix, '')
@regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
@method_missing_target = "#{@prefix}attribute#{@suffix}"
@method_name = "#{prefix}%s#{suffix}"
</code></pre>

<p>  end
<code>
代码中的`prefix`以及`suffix`是通过`Hash#fetch`方法提取出来的。这会返回一个对应键的值，或者是一个默认值。如果调用方法的时候没有提供默认值，`Hash#fetch`方法将会抛出一个异常，提示指定的键不存在。对于options的处理来说是一种不错的模式，特别是对于boolean型数据来说：
</code>ruby
options = {:name => &ldquo;Mortimer&rdquo;, :imaginary => false}</p>

<h1>Don&rsquo;t do this:</h1>

<p>options[:imaginary] || true     #=> true</p>

<h1>Do this:</h1>

<p>options.fetch(:imaginary, true) #=> false
```</p>

<p>对于我们的<code>attribute_method_suffix</code>其中的<code>'_changed'</code>示例来说，<code>AttributeMethodMatcher</code>将会有如下的实例变量：
<code>ruby
@prefix                #=&gt; ""
@suffix                #=&gt; "_changed?"
@regex                 #=&gt; /^(?:)(.*)(?:_changed\?)$/
@method_missing_target #=&gt; "attribute_changed?"
@method_name           #=&gt; "%s_changed?"
</code></p>

<p>你一定想知道<code>%s_changed</code>中的<code>%s</code>是用来干什么的吧？这是一个格式化字符串（format string）。你可以使用<code>sprintf</code>方法对它插入值，或者使用缩写（shortcut）<code>%</code>：
<code>ruby
sprintf("%s_changed?", "name") #=&gt; "named_changed?"
"%s_changed?" % "age"          #=&gt; "age_changed?"
</code></p>

<p>第二个比较有趣的地方就是正则表达式创建的方式。请留意创建<code>@regex</code>变量时<code>Regexp.escape</code>的用法。如果后缀没有被escape，则正则表达式中带有特殊含义的符号将会被错误解释(misinterpreted)：
```ruby</p>

<h1>Don&rsquo;t do this!</h1>

<p>regex = /^(?:#{@prefix})(.<em>)(?:#{@suffix})$/ #=> /^(?:)(.</em>)(?:_changed?)$/
regex.match(&ldquo;name_changed?&rdquo;)                 #=> nil
regex.match(&ldquo;name_change&rdquo;)                   #=> #<MatchData "name_change" 1:"name"></p>

<h1>Do this:</h1>

<p>@regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
regex.match(&ldquo;name_changed?&rdquo;)                 #=> #<MatchData "name_changed?" 1:"name">
regex.match(&ldquo;name_change&rdquo;)                   #=> nil
```</p>

<p>请仔细记住<code>regex</code>以及<code>method_name</code>，它们可以用来匹配和生成属性方法，我们在后面还会继续用到它们。</p>

<p>我们现在已经搞明白了属性方法是如何声明的，但是实际中，Rails又是如何使用它们的呢？</p>

<h3>通过Method Missing调用（Invocation With Method Missing）</h3>

<p>当我们调用了一个未定义的方法时，Rails将会在抛出异常之前调用对象的<code>method_missing</code>方法。让我们看看Rails是如何利用这个技巧调用属性方法的：
```ruby
def method_missing(method, *args, &amp;block)
  if respond_to_without_attributes?(method, true)</p>

<pre><code>super
</code></pre>

<p>  else</p>

<pre><code>match = match_attribute_method?(method.to_s)
match ? attribute_missing(match, *args, &amp;block) : super
</code></pre>

<p>  end
end
```</p>

<p>传给<code>method_missing</code>方法的第一个参数是一个用symbol类型表示的方法名，比如，我们的<code>:name_changed?</code>。<code>*args</code>是（未定义的）方法被调用时传入的所有参数，<code>&amp;block</code>是一个可选的代码块。Rails首先通过调用<code>respond_to_without_attributes</code>方法检查是否有别的方法可以对应这次调用。如果别的方法可以处理这次调用，则通过<code>super</code>方法转移控制权。如果找不到别的方法可以处理当前的调用，ActiveModel则会通过<code>match_attribute_method?</code>方法检查当前调用的方法是否是一个属性方法。如果是，它则会接着调用<code>attribute_missing</code>方法。</p>

<p><code>match_attribute_method</code>方法利用了之前声明过的<code>AttributeMethodMatcher</code>对象：
<code>ruby
def match_attribute_method?(method_name)
  match = self.class.send(:attribute_method_matcher, method_name)
  match if match &amp;&amp; attribute_method?(match.attr_name)
end
</code></p>

<p>在这个方法里边发生了两件事。第一，Rails查找到了一个匹配器(matcher)，并且检查这是否真的是一个属性。说实话，我自己也是比较迷惑，为什么<code>match_attribute_method?</code>方法调用的是<code>self.class.send(:attribute_method_matcher, method_name)</code>，而不是<code>self.attribute_method_matcher(method_name)</code>，但是我们还是可以假设它们的效果是一样的。</p>

<p>如果我们再接着看<code>attribute_method_matcher</code>，就会发现它的最核心的代码仅仅只是扫描匹配了<code>AttributeMethodMatcher</code>实例，它所做的事就是对比对象本身的正则表达式与当前的方法名：
<code>ruby
def attribute_method_matcher(method_name)
  #...
  attribute_method_matchers.detect { |method| method.match(method_name) }
  #...
end
</code></p>

<p>如果Rails找到了匹配当前调用的方法的属性，那么接下来所有参数都会被传递给<code>attribute_missing</code>方法：
<code>ruby
def attribute_missing(match, *args, &amp;block)
  __send__(match.target, match.attr_name, *args, &amp;block)
end
</code></p>

<p>这个方法将匹配到的属性名以及传入的任意参数或者代码块代理给了<code>match.target</code>。回头看下我们的实例变量，<code>match.target</code>将会是<code>attribute_changed?</code>，而且<code>match.attr_name</code>则是"name"。<code>__send__</code>方法将会调用<code>attribute_changed?</code>方法，或者是你定义的任意一个特殊的属性方法。</p>

<h3>元编程（Metaprogramming）</h3>

<p>有很多的方式可以对一个方法的调用进行分发（dispatch），如果这个方法经常被调用，那么实现一个<code>name_changed?</code>方法将会更为有效。Rails通过<code>define_attribute_methods</code>方法做到了对这类属性方法的自动定义：
```ruby
def define_attribute_methods(*attr_names)
  attr_names.flatten.each { |attr_name| define_attribute_method(attr_name) }
end</p>

<p>def define_attribute_method(attr_name)
  attribute_method_matchers.each do |matcher|</p>

<pre><code>method_name = matcher.method_name(attr_name)

define_proxy_call true,
                  generated_attribute_methods,
                  method_name,
                  matcher.method_missing_target,
                  attr_name.to_s
</code></pre>

<p>  end
end
```</p>

<p><code>matcher.method_name</code>使用了我们前面见到过的格式化字符串，并且插入了<code>attr_name</code>。在我们的例子中，<code>"%s_changed?"</code>变成了<code>"name_changed?"</code>。现在我们我们准备好了了解在<code>define_proxy_call</code>中的元编程。下面是这个方法被删掉了一些特殊场景下的代码的版本，你可以在阅读完这篇文章后自己去了解更多的代码。
```ruby
def define_proxy_call(include_private, mod, name, send, <em>extra)
  defn = &ldquo;def #{name}(</em>args)&rdquo;
  extra = (extra.map!(&amp;:inspect) &lt;&lt; &ldquo;*args&rdquo;).join(&ldquo;, &rdquo;)
  target = &ldquo;#{send}(#{extra})&rdquo;</p>

<p>  mod.module_eval &lt;&lt;-RUBY, <strong>FILE</strong>, <strong>LINE</strong> + 1</p>

<pre><code>#{defn}
  #{target}
end
</code></pre>

<p>  RUBY
end
```</p>

<p>这里为我们定义了一个新的方法。<code>name</code>就是正要被定义的方法名，而<code>send</code>则是处理器(handler)，另外的<code>extra</code>是属性名。<code>mod</code>参数是一个Rails用<code>generated_attribute_methods</code>方法生成的特殊的模块（module），它被嵌入（mixin）到我们的类中。现在让我们多看一下<code>module_eval</code>方法。这里有三件有趣的事情发生了。</p>

<p>第一件事就是<a href="http://blog.jayfields.com/2006/12/ruby-multiline-strings-here-doc-or.html">HEREDOC</a>被用作一个参数传给了一个方法。这是有点难懂的，但是对某些场景却是非常有用的。举个例子，想象我们在一个服务器响应(response)中有一个方法要用来嵌入Javascript代码：
<code>ruby
include_js(&lt;&lt;-JS, :minify =&gt; true)
  $('#logo').show();
  App.refresh();
JS
</code></p>

<p>这将会把字符串<code>"$('#logo').show(); App.refresh();"</code>作为调用<code>include_js</code>时传入的第一个参数，而<code>:minify =&gt; true</code>作为第二个参数。在Ruby中需要生成代码时，这是一个非常有用的技巧。值得高兴的是，诸如<a href="https://github.com/textmate/textmate">TextMate</a>这类编辑器都能够识别这个模式，并且正确地高亮显示字符串。即使你并不需要生成代码，HEREDOC对于多行的字符串也是比较有用的。</p>

<p>现在我们就知道了<code>&lt;&lt;-RUBY</code>做了些什么事，但是<code>__FILE__</code>以及<code>__LINE__ + 1</code>呢？<code>__FILE__</code>返回了当前文件的（相对）路径，而<code>__LINE__</code>返回了当前代码的行号。<code>module_eval</code>接收这些参数，并通过这些参数决定新的代码定义在文件中“看起来”的位置。在对于栈跟踪（stack traces）来说是特别有用的。</p>

<p>最后，让我们看一些<code>module_eval</code>中实际执行的代码。我们可以把值替换成我们的<code>name_changed?</code>：
```ruby
mod.module_eval &lt;&lt;-RUBY, <strong>FILE</strong>, <strong>LINE</strong> + 1
  def name_changed?(*args)</p>

<pre><code>attribute_changed?("name", *args)
</code></pre>

<p>  end
RUBY
<code>``
现在</code>name_changed?<code>就是一个真实的方法了，比起依赖于</code>method_missing`方法的实现，这种方法的开销要小得多。</p>

<h3>总结（Recap）</h3>

<p>我们发现了调用<code>attribute_method_suffix</code>方法会保存一个配置好的对象，这个对象用于Rails中两种元编程方法中的一种。不考虑是否使用了<code>method_missing</code>，或者通过<code>module_eval</code>定义了新的方法，方法的调用最后总会被传递到诸如<code>attribute_changed?(attr)</code>这样的方法上。</p>

<p>走过这次比较宽泛的旅途，我们也收获了一些有用的技巧：</p>

<ul>
<li>你必须使用<code>Hash#fetch</code>从options中读取参数，特别是对于boolean类型参数来说。</li>
<li>诸如<code>"%s_changed"</code>这样的格式化字符串，可以被用于简单的模板。</li>
<li>可以使用<code>Regexp.escape</code>escape正则表达式。</li>
<li>当你试图调用一个未定义的方法时，Ruby会调用<code>method_missing</code>方法。</li>
<li>HEREDOCs可以用在方法参数中，也可以用来定义多行的字符串。</li>
<li><code>__FILE__</code>以及<code>__LINE__</code>指向当前的文件以及行号。</li>
<li>你可以使用<code>module_eval</code>动态生成代码。</li>
</ul>


<p>坚持浏览Rails的源代码吧，你总会发现你原本不知道的宝藏！</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>《解读Rails》中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跟踪model中属性（值）的变更]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/07/zhui-zong-bian-geng/"/>
    <updated>2014-03-07T13:02:47+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/07/zhui-zong-bian-geng</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_change_tracking/">Reading Rails &ndash; Change Tracking</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>我们今天来看看Rails是如何追踪model里边属性的变更的。
<code>ruby
person = Person.find(8)
person.name = "Mortimer"
person.name_changed?    #=&gt; true
person.name_was         #=&gt; "Horton"
person.changes          #=&gt; {"name"=&gt;["Horton","Mortimer"]}
person.save!
person.changes          #=&gt; {}
</code>
<code>name_changed?</code>方法是从哪来的呢？变更又是如何被创建的？让我们顺着这个场景，看看这一切背后的秘密。</p>

<!-- More -->


<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>ActiveModel</h3>

<p>当你想探寻ActiveRecord里边的功能时，你应该首先了解ActiveModel。ActiveModel（<strong>提示</strong>： 命令行中键入<code>qw activemodel</code>查看代码）定义了没有与数据库捆绑的逻辑。我们将从<code>dirty.rb</code>文件开始。在这个模块最开始的地方，代码调用了<code>attribute_method_suffix</code>：
``` ruby
module Dirty
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods</p>

<p>  included do</p>

<pre><code>attribute_method_suffix '_changed?', '_change', '_will_change!', '_was'
#...
</code></pre>

<p><code>
`attribute_method_suffix`定义了定制的属性读写器。这主要用来告诉Rails将一些带有类似`_changed?`后缀的调用分发到特定的处理器方法上。为了看看它们是如何实现的，请向下滚动代码，并且找到`def attribute_changed?`：
</code> ruby
def attribute_changed?(attr)
  changed_attributes.include?(attr)
end
<code>
我们将会在另外的一篇文章中再着重介绍如何连接这些方法的细节，当你调用一个类似`name_changed?`的方法时，Rails将会把`"name"`作为参数`attr`传给上述方法。往回看一点点，你会发现`changed_attributes`只是一个包含了从属性名到旧的属性值的映射的`Hash`而已：
</code> ruby</p>

<h1>Returns a hash of the attributes with unsaved changes indicating their original</h1>

<h1>values like <tt>attr => original value</tt>.</h1>

<p>#</p>

<h1>person.name # => &ldquo;bob&rdquo;</h1>

<h1>person.name = &lsquo;robert&rsquo;</h1>

<h1>person.changed_attributes # => {&ldquo;name&rdquo; => &ldquo;bob&rdquo;}</h1>

<p>def changed_attributes
  @changed_attributes ||= {}
end
<code>``
在Ruby中，如果你之前都没有见过</code>||=<code>操作，那么你可能需要了解这其实是一个用于初始化变量值的技巧。当它第一次被访问的时候，变量的值是</code>nil<code>，所以它返回了一个空的</code>Hash<code>并且用其初始化</code>@changed_attributes<code>。当它再一次被访问的时候，</code>@changed_attributes<code>已经被赋值过了。那么现在我们可以回答我们的第一个问题了，</code>name_changed?<code>方法被转发到</code>attribute_changed?<code>方法，而后者会在</code>changed_attributes`中查找特定的值。</p>

<p>在我们的例子中，我们看到<code>changes</code>返回一个类似<code>{"name"=&gt;["Horton","Mortimer"]}</code>这样既包含旧的属性值，又包含新的属性值的<code>Hash</code>。让我们这又是如何做到的：
<code>ruby
def changes
  ActiveSupport::HashWithIndifferentAccess[changed.map { |attr| [attr, attribute_change(attr)] }]
end
</code>
这段代码看起来有点难以理解，但是我们可以一步一步分析。首先我们从<code>ActiveSupport::HashWithIndifferentAccess</code>开始，这是在ActiveSupport中所定义的<code>Hash</code>的子类，通过字符串类型或者符号类型的键去访问它将得到一样的结果：
<code>ruby
hash = ActiveSupport::HashWithIndifferentAccess.new
hash[:name] = "Mortimer"
hash["name"] #=&gt; "Mortimer"
</code>
接下来就有点奇怪了，Rails调用了<code>Hash[]</code>方法。这是一个鲜为人知的从包含键/值对的数组中初始化一个哈希表的方法。
<code>ruby
Hash[
  [:name, "Mortimer"],
  [:species, "Crow"]
] #=&gt; {[:name, "Mortimer"]=&gt;[:species, "Crow"]}
</code>
可以查看<code>Hash Tricks</code>找到更多类似的方法。<code>changes</code>中剩余部分的代码就比较清晰了。属性名被映射到类似<code>[attr, attribute_change(attr)]</code>的数组。其中第一个元素，也就是<code>attr</code>编程了一个键，而对应的值则是<code>attribute_change(attr)</code>返回的结果。
<code>ruby
def attribute_change(attr)
  [changed_attributes[attr], __send__(attr)] if attribute_changed?(attr)
end
</code>
这是另一个被分发的属性方法，但是在这个例子里，它返回了一个包含了两个元素的数组，第一个元素是从<code>changed_attributes</code>哈希表中读到的<code>attr</code>所对应的旧的值，第二个则是所对应的新的值。Rails通过使用<code>__send__</code>方法调用了名为<code>attr</code>的方法，进而得到新的属性值。然后这对值会被返回，并且用作<code>changes</code>哈希表中<code>attr</code>所对应的值。</p>

<h3>ActiveRecord</h3>

<p>现在让我们来找出Rails是如何记录更改的。ActiveRecord实现了读写ActiveModel所跟踪的属性的代码。跟ActiveModel一样，ActiveRecord也有一个<code>dirty.rb</code>文件，我们将要对这个文件进行挖掘。通过在定义了<code>changed_attributes</code>的文件中（<strong>提示</strong>：命令行中键入<code>qw activerecord</code>）找到的相关代码，我们可以看到这个文件包装了ActiveRecord的<code>write_attribute</code>与逻辑以实现对变更的跟踪。
``` ruby</p>

<h1>Wrap write_attribute to remember original attribute value.</h1>

<p>def write_attribute(attr, value)
  attr = attr.to_s</p>

<p>  # The attribute already has an unsaved change.
  if attribute_changed?(attr)</p>

<pre><code>old = @changed_attributes[attr]
@changed_attributes.delete(attr) unless _field_changed?(attr, old, value)
</code></pre>

<p>  else</p>

<pre><code>old = clone_attribute_value(:read_attribute, attr)
@changed_attributes[attr] = old if _field_changed?(attr, old, value)
</code></pre>

<p>  end</p>

<p>  # Carry on.
  super(attr, value)
end
<code>
让我们暂时偏离一下主题，并且看一下方法的包装。这是在Rails的代码里边非常常见的模式。当你调用`super`的时候，Ruby查找当前对象的所有祖先，包括相关的模块。由于一个类可以引进多个模块，所以你可以多层地包装方法。这里是一个简单的例子：
</code> ruby
module Shouting
  def say(message)</p>

<pre><code>message.upcase
</code></pre>

<p>  end
end</p>

<p>class Speaker
  include Shouting</p>

<p>  def say(message)</p>

<pre><code>puts super(message)
</code></pre>

<p>  end
end</p>

<p>Speaker.new.say(&ldquo;Hi!&rdquo;) #=> &ldquo;HI!&rdquo;
<code>``
请注意</code>Shouting<code>是</code>Speaker<code>所包含的模块，而不是后者所扩展的类。Rails使用这种技巧去包装方法，以此确保在不同的文件里有独立的关注点（Concern）。这也意味着为了了解整个系统，你可能需要从多个文件里边找到相关的代码。假如你看到了一个对</code>super`的调用，这是一个可以告诉你在别的地方还有更多代码需要了解的好线索。假如你想学习更多的这方面的知识，James Coglan有一个非常详细的文章讲解了Ruby的<a href="https://blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works/">方法分发</a>。</p>

<p>回到<code>write_attribute</code>方法。根据属性（值）是否已经改变，会有两个可能的场景。第一个分支检查你是否正在将一个属性（值）还原到原来的值，如果是这样，它将会从记录了已改变属性的哈希表中删除属性。第二个分支仅仅在新的值与旧的值不同的时候记录下更改。一旦更改被记录下来，实际的用于更新属性的逻辑通过调用<code>super</code>方法完成。</p>

<h3>总结</h3>

<p>Rails为你的model提供了变更的跟踪。这个功能是在ActiveModel中实现的，但是真正的监测更改的逻辑则是在ActiveRecord中实现的。</p>

<p>通过了解这个功能，我们也发掘到了一些有趣的小贴士：</p>

<ul>
<li>ActiveModel定义了<code>attribute_method_suffix</code>方法用于分发类似<code>name_changed?</code>的方法。</li>
<li><code>||=</code>操作符是一个可以用来初始化变量的方便的方法。</li>
<li>在<code>HashWithIndifferentAccess</code>中，字符串类型以及符号类型的键是一样的。</li>
<li><code>Hash</code>可以通过<code>Hash[key_value_pairs]</code>方法初始化。</li>
<li>你可以使用模块拦截方法并为方法加上另一层的功能。</li>
</ul>


<p>假如你有关于你想阅读的关于Rails中其他部分的建议，请让我知道。</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>“解读Rails”中的文章。“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解读Rails - 处理异常]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang/"/>
    <updated>2014-03-05T13:53:09+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_handling_exceptions/">Reading Rails &ndash; Handling Exceptions</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>我们今天开始会读一些Rails的源码。我们有双重的目的，先通过学习（Rails）如何处理异常，再扩展到整个Ruby中基础知识的学习。</p>

<!-- More -->


<p>Rails通过让你使用<code>rescue_from</code>方法，让你在你的<code>controller</code>里边为常见的异常定义处理方法。举例来说吧，你可以在用户试图访问他们尚未付费的功能时将他们重定向到指定的付费页面。
``` ruby
class ApplicationController
  # Redirect users if they try to use disabled features.
  rescue_from FeatureDisabledError, InsufficientAccessError do |ex|</p>

<pre><code>flash[:alert] = "Your account does not support #{ex.feature_name}"
redirect_to "/pricing"
</code></pre>

<p>  end
  #&hellip;
```
我们将会探索Rails是如何定义异常处理器，如何将它们与具体的异常进行匹配，以及如何使用它们去rescue失败的action。</p>

<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>定义处理器(Handlers)</h3>

<p>ActiveSupport包含了一个用于定义异常如何被处理的模块<code>Rescuable</code>。第一个需要了解的方法就是<code>rescue_from</code>。这个方法通过方法名或者代码块为你想rescue的异常注册处理器（<strong>提示</strong>：查看代码，请在命令行中输入<code>qw activesupport</code>）：
``` ruby
def rescue_from(*klasses, &amp;block)
  options = klasses.extract_options!</p>

<p>  unless options.has_key?(:with)</p>

<pre><code>if block_given?
  options[:with] = block
else
  #...
</code></pre>

<p><code>``
首先，</code>*klasses<code>接收数量不定的异常类，所以你可以进行类似</code>rescue_from(FeatureDisabledError, InsufficientAccessError)`这样的调用。它们将会被存放在一个数组里。</p>

<p>接下来，请留意<code>extract_options!</code>的使用。这是一个常见的用于从一个数组生成一个options哈希表的技巧。假如klasses里边的最后一个元素是一个哈希表，那么这个元素会被弹出数组。现在Rails将会使用<code>:with</code>项所指定的方法，或者是使用传递给rescue_from的代码块。Rails中的这种技巧创造了一个灵活的接口。</p>

<p>接着继续往下看这个方法，我们看到每一个异常类都被转换成一个String对象，我们待会便会看到为什么要这么做。
``` ruby
def rescue_from(*klasses, &amp;block)
  #&hellip;</p>

<pre><code>key = if klass.is_a?(Class) &amp;&amp; klass &lt;= Exception
  klass.name
elsif klass.is_a?(String)
  klass
else
</code></pre>

<p>  #&hellip;
<code>``
这里你应该注意的是，Rails是如何判定</code>klass<code>是不是继承自</code>Exception<code>的。通常情况下，你可能会通过使用</code>obj.is_a?(Exception)<code>来判断一个对象是不是某一个具体类型的实例，即使如此，</code>klass<code>并不是</code>Exception<code>，而只是</code>Class<code>。那么我们又怎么找出它使哪一类呢？Ruby在</code>Module<code>上定义了类似</code>&lt;=<code>这样的[用于比较的操作符](http://ruby-doc.org/core-1.9.3/Module.html#method-i-3C)。当操作符左边的对象是操作符右边对象的子类的时候，它会返回true。举个例子，</code>ActiveRecord::RecordNotFound &lt; Exception<code>返回true，而</code>ActiveRecord::RecordNotFound > Exception`返回false。</p>

<p>在这个方法的末尾，我们看到表示异常类的<code>String</code>对象稍后被储存在二元数组中：
<code>ruby
def rescue_from(*klasses, &amp;block)
  #...
  self.rescue_handlers += [[key, options[:with]]]
end
</code>
现在我们已经知道了处理器是如何储存的，但是当Rails需要处理异常的时候，它又是如何查找这些处理器的呢？</p>

<h3>查找处理器（Finding Handlers）</h3>

<p>经过对<code>rescue_handlers</code>的快速搜索发现，这一切使用到了<code>handler_for_rescue</code>。我们可以看到每一个可能的处理器都被一一检查，直到我们找到能够与<code>exception</code>匹配的处理器：
``` ruby
def handler_for_rescue(exception)
  # 我们遵循从右到左的顺序，是因为每当发现一个rescue_from声明的时候，
  # 相应的klass_name, handler对就会被压入resuce_handlers里。
  _, rescuer = self.class.rescue_handlers.reverse.detect do |klass_name, handler|</p>

<pre><code>#...
klass = self.class.const_get(klass_name) rescue nil
klass ||= klass_name.constantize rescue nil
exception.is_a?(klass) if klass
</code></pre>

<p>  end
  #&hellip;
<code>``
如同注释所言，</code>rescue_handlers<code>被反序读取。假如有两个处理器能够处理同一个异常，那么最后定义的处理器会被优先选中。假如你先定义了一个针对</code>ActiveRecord::NotFoundError<code>异常的处理器，接着又定义了针对</code>Exception<code>异常的处理器，那么前者将永远都不会被调用，因为针对</code>Exception`的处理器总是会优先匹配。</p>

<p>现在，在代码块里边，又发生了什么呢？</p>

<p>首先，字符串对象<code>klass_name</code>被当做当前类内部的常量进行查找，在找不到的情况下会继续判断它是不是定义在程序内部其他地方的常量，以此将<code>klass_name</code>转换为实际的类。每一步都通过返回<code>nil</code>进行rescue。这么做的一个原因就是当前处理器可能是针对某个尚未加载的异常的类型。举例来说，一个插件里可能为<code>ActiveRecord::NotFoundError</code>定义了错误处理，但是你可能并没有使用<code>ActiveRecord</code>。在这样的情况下，引用这个异常将会导致异常。每一行最后的<code>rescue nil</code>能够在无法找到类时无声无息地组织异常的抛出。</p>

<p>最后我们检查这个异常（等待匹配的异常）是否是这个处理器所对应异常类的实例。如果是，数组<code>[klass_name, handler]</code>将会被返回。返回到上边看看<code>_, rescuer = ...</code>这一行代码，这一一个数组拆分的例子。因为我们实际上只想要返回数组的第二个元素，也就是处理器，所以<code>_</code>在这里只是一个占位符。</p>

<h3>处理异常（Rescuing Exceptions)</h3>

<p>现在我们知道了程序是如何查找异常处理器的，但是它又是如何被调用的呢？为了回答这最后一个问题，我们可以返回到源代码文件的顶部然后探索一下<code>rescue_with_handler</code>方法。当给它传递一个异常的时候，它将会尝试通过调用合适的处理器来处理这个异常。
``` ruby
def rescue_with_handler(exception)
  if handler = handler_for_rescue(exception)</p>

<pre><code>handler.arity != 0 ? handler.call(exception) : handler.call
</code></pre>

<p>  end
end
<code>
为了了解这个方法是如何在你的controller里边生效的，我们需要查看ActionPack包里边的代码。（**提示**：可以在命令行中键入`qw actionpack`打开ActionPace的代码）Rails定义了一个叫做`ActionController::Rescue`的中间件，它被混入到了`Rescuable`模块里边，并且通过`precess_action`调用。
</code> ruby
def process_action(*args)
  super
rescue Exception => exception
  rescue_with_handler(exception) || raise(exception)
end
<code>``
Rails在收到每一个请求时都会调用</code>process_action<code>，假如请求导致一个异常即将被抛出，</code>rescue_with_handler`都会试图去处理这个异常。</p>

<h3>在Rails之外使用Rescuable（Using Rescuable Outside of Rails）</h3>

<p><code>Rescuable</code>能够被混入到其它代码之中。假如你想集中化你的异常处理部分的逻辑，那么你可以考虑一下使用<code>Rescuable</code>。举个例子，假如你有很多发向远程服务的请求，并且你不想在每一个方法里边重复异常处理的逻辑：
``` ruby
class RemoteService
  include Rescuable</p>

<p>  rescue_from Net::HTTPNotFound, Net::HTTPNotAcceptable do |ex|</p>

<pre><code>disable_service!
log_http_failure(@endpoint, ex)
</code></pre>

<p>  end</p>

<p>  rescue_from Net::HTTPNetworkAuthenticationRequired do |ex|</p>

<pre><code>authorize!
</code></pre>

<p>  end</p>

<p>  def get_status</p>

<pre><code>#...
</code></pre>

<p>  rescue Exception => exception</p>

<pre><code>rescue_with_handler(exception) || raise(exception)
</code></pre>

<p>  end</p>

<p>  def update_status</p>

<pre><code>#...
</code></pre>

<p>  rescue Exception => exception</p>

<pre><code>rescue_with_handler(exception) || raise(exception)
</code></pre>

<p>  end</p>

<p>end
```
使用一点元编程的技巧，你甚至可以通过类似的模式对已有的方法进行封装以避免rescue代码块。</p>

<h3>总结（Recap）</h3>

<p>ActiveSupport的<code>Rescuable</code>模块允许我们定义异常处理方法。ActionController的<code>Rescue</code>中间件捕捉异常，并试图处理这些异常。
我们也同时了解到：</p>

<ul>
<li>一个签名类似<code>rescue_from(*klasses)</code>的方法可以接收数量不定的参数。</li>
<li><code>Array#extract_options!</code>方法是一个用于从arguments数组得到options的技巧。</li>
<li>你可以通过类似<code>klass &lt;= Exception</code>这样的代码判读一个类是否某个类的子类。</li>
<li><code>rescue nil</code>将会静默地消除异常。</li>
</ul>


<p>就算是再小的代码片段都包含了非常多有用的信息，请让我知道你下一步想要了解什么东西，我们还会看到能够从Rails里边挖掘到的新奇玩意。</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>“解读Rails”中的文章。“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Ruby中使用WebSocket]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/01/zai-rubyzhong-shi-yong-websocket/"/>
    <updated>2014-03-01T21:31:03+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/01/zai-rubyzhong-shi-yong-websocket</id>
    <content type="html"><![CDATA[<p><strong>声明</strong>: 此文翻译自<a href="http://www.troikatech.com/blog/2014/02/26/websocket-webmachine/?utm_source=rubyweekly&amp;utm_medium=email">WebSockets in Ruby</a>， 限于本人才疏学浅，其中有翻译不当之处，敬请指出，感激不尽！</p>

<p>在我的主要工作中，需要构建一个一直占用相当大CPU时间片的数据系统。这个任务主要用于在地理编码以及local reference system(本地地理系统？)之间进行编码以及解码。举个例子，这个工作将帮助我们在系统中标记一条对应于街道上某个地点的记录，并且可以知道本地地理位置所对应的坐标。</p>

<!-- More -->


<p>在第一次的尝试中，我开发了一个用于地理编码的Ruby库以及一个简单的基于Sinatra的web服务。当时我的解决方案表现得还不错，直到后来客户要求对每一个鼠标滑过的事件进行交互。这个需求上的更改让我不得不再一次通过Javascript语言去构建一个同样用于地理编码的基础构件，在之后的一段时间里，一切也都表现得非常好。</p>

<p>而意料之中的是，我们再一次决定在系统中允许每个用户与多个街道关联。现在，每次下载800KB的数据（存储在索引数据库中，用于记录最新的会话信息）尚且可以承受；但是潜在上来说，几个MB的数据将是致命的，甚至软件也有可能在会话的响应之前被使用-而这只是用户所期待的功能之一。</p>

<p>我知道我们必须寻找一个完美的解决方案，并且使一切都是可以管理控制的。在以前，我涉足过WebSocket领域（比如node.js以及Socket.IO）并且知道相关的底层知识。从之前的搜索中，我意识到Ruby在这方面的欠缺，我很快又考虑通过在节点上的Javascript端口来实现需求。这样的想法使我非常激动。</p>

<h2>可选方案</h2>

<p>第一步是找出可用的方案。以下列举我找到的：</p>

<ol>
<li><a href="https://github.com/simulacre/sinatra-websocket">sinatra-websocket</a></li>
<li><a href="https://github.com/faye/faye-websocket-ruby">faye-websocket</a></li>
<li><a href="https://github.com/websocket-rails/websocket-rails">websocket-rails</a></li>
<li><a href="https://github.com/ngauthier/tubesock">tubesock</a></li>
<li><a href="https://github.com/seancribbs/webmachine-ruby">webmachine-ruby</a></li>
</ol>


<p>在上述五种方案中，前三种方案都是基于事件机制的，而<code>tubesock</code>使用了rake hijacking技术，<code>webmachine-ruby</code>通过基于<code>Celluloid::IO</code>的HTTP服务器Reel提供WebSockets。</p>

<p>首先，考虑到我已经使用了Sinatra，于是我试用了<code>sinatra-websocket</code>。但是因为部分原因，我无法将连接方式迁移到WebSocket，所以我决定快速跳过。而且坦白说的话，我还直接跳过了<code>faye-websocket</code>。</p>

<p>接下来的两个备选方案遇到了同样的问题：在一个配置较低的Heroku的站点上启动Rails并且加载了整个系统之后，剩下的内存只够几十个客户端同时使用的了。除此之外，Rails的启动时间加上其他用于构建的时间偶尔会让Heroku认为系统中出现异常，结果导致进程在服务正常启动之前就已经被强行退出了。</p>

<p>假如你有所留意，那么你也就知道了，剩下的唯一一个方案，就是<code>webmachine-ruby</code>。</p>

<h2>webmachine-ruby</h2>

<p>配置<code>webmachine-ruby</code>的环境还是相对容易的。为了逐步进行，我首先把原来基于HTTP的服务迁移到它的资源结构。比起Rails以及Sinatra，它更加具有面向对象的味道。它的分发器是易于理解的，我非常喜欢通过<a href="https://github.com/seancribbs/webmachine-ruby#visual-debugger">visual debugger</a>来摆玩这一切。</p>

<p>迁移到WebSocket上后，一切都变了。我能建议的（包括文档中说明的）就是，你完全可以跳过常规的基础配置，转而提供一个可调用的配置项，比如：
``` ruby
App = Webmachine::Application do |app|
  app.configure do |config|</p>

<pre><code>config.adapter = :Reel
config.adapter_options[:websocket_handler] = proc do |websocket|
  websocket &lt;&lt; "hello, world"
end
</code></pre>

<p>  end
end
<code>
这是相当多的文档所提到的方法。因为它只期望handler支持`#call`方法，所以你可以写一个你自己的ad-hoc分发器：
</code> ruby
class WebsocketHandler
  def call(websocket)</p>

<pre><code>message = websocket.read
# do something with the message, call methods on other objects, log stuff, have your fun
</code></pre>

<p>  end
end
<code>
很多文档并不提及一些套接字编程的基础。假如你发现你的handler被挂起并且不再处理响应，这意味着你需要重新修改程序，但是不需要为此感到烦恼：你只需要实现一个不断从套接字中读取信息并且让`Celluloid::IO`实现它的非阻塞魔术方法的循环就行了：
</code> ruby
class WebsocketHandler
  def call(websocket)</p>

<pre><code>loop do
  message = websocket.read
  # do something with the message, call methods on other objects, log stuff, have your fun
end
</code></pre>

<p>  end
end
```</p>

<p>因为非阻塞的特点，你不再需要担心你的CPU占用会一直停留在100%。然而，你会受到节点在CPU使用率以及事件处理方面同样的限制（比如，假如你的程序是CPU密集型的，它便会影响自身的吞吐量）。</p>

<p>幸运的是，我们可以在Ruby中使用线程。我决定通过为每一个客户端指定一个<code>Celluloid Actor</code>来好好利用线程。这个做法允许我去提供一些CPU密集型的操作而不需要妥协于系统中的其他用户。到目前为止，这个方案表现得不错。</p>

<h2>疏漏的地方</h2>

<p>我的解决方案本来应该考虑非WebSocket的客户端，但事实上我却没有做到。<code>webmachine-ruby</code>通过允许你实现流式API而将此变得简单且没有后顾之忧。我想这将只需要一些JS代码去做相互之间的反馈并且提供一个指向接收者的连接。</p>

<p>这篇文档并未涵盖所有可能在套接字连接时出现的事件（onerror, on close, onopen, onmessage）。你可以在连接套接字的时候看到它们，并且每一个都带着一个块。</p>

<p>这个工具也并不提供一个成熟的结合频道以及信息代理的发布/订阅系统。如果你更多的是需要这方面的工具，其实可以考虑使用<code>faye</code>以及<code>websocket-rails</code>。</p>
]]></content>
  </entry>
  
</feed>
