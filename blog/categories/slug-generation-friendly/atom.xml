<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: slug generation friendly | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/slug-generation-friendly/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2017-10-15T15:52:54+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 chinese_pinyin + friendly_id 为中文标题生成 slug]]></title>
    <link href="http://Martin91.github.io/blog/articles/2015/10/21/use-chinese-pinyin-and-friendly-id-to-generate-slugs/"/>
    <updated>2015-10-21T22:20:07+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2015/10/21/use-chinese-pinyin-and-friendly-id-to-generate-slugs</id>
    <content type="html"><![CDATA[<p>在许多项目中，我们可能都会遇到需要为数据生成 slug 的场景，这些场景类似于：</p>

<ul>
<li>基于商品名称生成 slug</li>
<li>基于文章标题生成 slug</li>
</ul>


<p>至于为什么需要生成 slug，而不是使用比如 Rails 中默认自增的主键也就是数据的 id，原因其实很简单：</p>

<ul>
<li>使用自增 id 容易暴露数据，比如通过订单 id 可能导致遍历所有订单，不信，你看这里就有个<a href="http://www.wooyun.org/bugs/wooyun-2015-0127301">例子</a></li>
<li>增加 URL 友好性，/products/18376 这样的链接肯定没有比 /products/apple-watch-gold 这样的链接更招人喜欢</li>
</ul>


<!-- MORE -->


<h3><a href="https://github.com/norman/friendly_id">friendly_id</a></h3>

<p>friendly_id 是用来生成 slug 的 ruby gem，假设我们有一个产品模型 <code>Product</code>，使用 friendly_id 为商品名称(<code>name</code>)生成 slug 的示例代码如下：</p>

<p><code>ruby
class Product &lt; ActiveRecord::Base
  friendly_id :name, use: :slugged
end
</code>
上面的代码理论上来说已经完成我们所需要的工作了，但是如果 title 包含中文的话，生成的 slug 就有点类似 <code>30f175f4-1e56-4e3a-823d-a7c1a5d32b29</code> 这样的乱码了，实际上这个 slug 对应的原来的 title 是 <code>测试产品</code>。这样的 slug 虽然避免了自增 id 的弊端，但是却丧失了友好性。如果 slug 能够基于汉语拼音生成，岂不更好？</p>

<h3>自己控制 slug 生成方式</h3>

<p>阅读 <a href="https://github.com/norman/friendly_id/blob/master/lib/friendly_id/slugged.rb#L290-L292">friendly_id 的源码</a>可以找到以下代码：</p>

<p>```ruby
module FriendlyId
  module Slugged</p>

<pre><code># ...

def normalize_friendly_id(value)
  value.to_s.parameterize
end

# ...
</code></pre>

<p>  end
end
<code>``
这段代码便是 friendly_id 基于输入生成 slug 的核心代码，使用 ActiveSupport 扩展后的</code>String<code>类的 [</code>parameterize<code>](http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-parameterize) 方法，此方法会将除了英文字母、数字、短横线以及下划线之外的字符转换为</code>&ndash;`，所以不适用于中文的情况，我们需要<a href="https://github.com/norman/friendly_id/blob/master/lib/friendly_id/slugged.rb#L259-L261">重写该方法</a>，以满足我们的需求。</p>

<h3>中文拼音利器——<a href="https://github.com/flyerhzm/chinese_pinyin">chinese_pinyin</a></h3>

<p>中文生成中文拼音的工具，我选择了黄志敏先生写的 <code>chinese_pinyin</code> 这个 gem，推荐理由就是简单够用。</p>

<p>以下是单独使用这个 gem 时的示例：</p>

<p><code>ruby
2.2.0 :009 &gt; Pinyin.t("中国人")
 =&gt; "zhong guo ren"
2.2.0 :010 &gt; Pinyin.t("Hello, 李雷")
 =&gt; "Hello  li lei"
</code></p>

<h3>组装！！！</h3>

<p>根据 <a href="https://github.com/norman/friendly_id/blob/master/lib/friendly_id/slugged.rb#L259-L261">friendly_id 的注释</a>，如果你只需要为单独一个 model 定制 slug 的生成逻辑，那么建议你只在相关的 model 中定义同名方法即可。但是由于我是需要为多个 model 定制中文的 slug 生成逻辑，所以我选择了直接重定义 <code>FriendlyId::Slugged</code> 模块中的这个方法：</p>

<p>```ruby</p>

<h1>config/initializers/friendly_id/slugged.rb</h1>

<p>module FriendlyId
  module Slugged</p>

<pre><code># 重定义 friendly_id 方法，实现 slug 从中文到拼音，非中文不受影响
def normalize_friendly_id(value)
  Pinyin.t(value.to_s).parameterize
end
</code></pre>

<p>  end
end
<code>``
这样的定义方式使得新的</code>normalize_friendly_id` 方法对所有依赖 friendly_id 的代码都生效。</p>

<p>最后通过新的方法为我们的产品生成新的 slug，现在“测试产品”得到的 slug 变为 <code>ce-shi-chan-pin</code> 了：</p>

<p><code>ruby
product.update(slug: nil)  # 显式清空 slug, friendly_id 在 save 时会自动重新生成 slug
</code></p>

<p>最后产品的链接已变为 <code>/products/ce-shi-chan-pin</code>，比起 <code>/products/30f175f4-1e56-4e3a-823d-a7c1a5d32b29</code>，可真是叫人心旷神怡。</p>
]]></content>
  </entry>
  
</feed>
