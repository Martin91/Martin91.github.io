
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>解读Rails - 适配器模式 - Martin</title>
	<meta name="author" content="Martin">

	
	<meta name="description" content="本文翻译自Reading Rails &ndash; The Adapter Pattern，限于本人水平有限，翻译不当之处，敬请指教！ 今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是适配器模式（Adapter Pattern）。 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="Martin" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="/javascripts/jquery-1.11.1.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">Martin</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:Martin91.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:Martin91.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">解读Rails - 适配器模式</h2>
	<div class="entry-content"><p>本文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_the_adapter_pattern/?utm_source=rubyweekly&amp;utm_medium=email">Reading Rails &ndash; The Adapter Pattern</a>，限于本人水平有限，翻译不当之处，敬请指教！</p>

<p>今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是<a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式（Adapter Pattern）</a>。从一定的意义上来说，这次的探索并不全面，但是我希望能够突出一些实际的例子。</p>

<!-- MORE -->


<p>为了跟随本文的步骤，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开相关的代码库，或者直接在<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github</a>上查看这些代码。</p>

<h3>适配器模式</h3>

<p><a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式</a>可以用于对不同的接口进行包装以及提供统一的接口，或者是让某一个对象看起来像是另一个类型的对象。在静态类型的编程语言里，我们经常使用它去满足类型系统的特点，但是在类似Ruby这样的弱类型编程语言里，我们并不需要这么做。尽管如此，它对于我们来说还是有很多意义的。</p>

<p>当使用第三方类或者库的时候，我们经常从这个例子开始（start out fine）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">find_nearest_restaurant</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
</span><span class='line'>  <span class="n">locator</span><span class="o">.</span><span class="n">nearest</span><span class="p">(</span><span class="ss">:restaurant</span><span class="p">,</span> <span class="nb">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="nb">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们假设有一个针对<code>locator</code>的接口，但是如果我们想要<code>find_nearest_restaurant</code>能够支持另一个库呢？这个时候我们可能就会去尝试添加新的特殊的场景的处理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">find_nearest_restaurant</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">locator</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">GeoFish</span>
</span><span class='line'>    <span class="n">locator</span><span class="o">.</span><span class="n">nearest</span><span class="p">(</span><span class="ss">:restaurant</span><span class="p">,</span> <span class="nb">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="nb">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
</span><span class='line'>  <span class="k">elsif</span> <span class="n">locator</span><span class="o">.</span><span class="n">is_a?</span> <span class="no">ActsAsFound</span>
</span><span class='line'>    <span class="n">locator</span><span class="o">.</span><span class="n">find_food</span><span class="p">(</span><span class="ss">:lat</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span> <span class="ss">:lon</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="o">.</span><span class="n">lon</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">locator</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not supported.&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个比较务实的解决方案。或许我们也不再需要考虑去支持另一个库了。也或许<code>find_nearest_restaurant</code>就是我们使用<code>locator</code>的唯一场景。</p>

<p>那假如你真的需要去支持一个新的<code>locator</code>，那又会是怎么样的呢？那就是你有三个特定的场景。再假如你需要实现<code>find_nearest_hospital</code>方法呢？这样你就需要在维护这三种特定的场景时去兼顾两个不同的地方。当你觉得这种解决方案不再可行的时候，你就需要考虑适配器模式了。</p>

<p>在这个例子中，我们可以为<code>GeoFish</code>以及<code>ActsAsFound</code>编写适配器，这样的话，在我们的其他代码中，我们就不需要了解我们当前正在使用的是哪个库了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">find_nearest_hospital</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
</span><span class='line'>  <span class="n">locator</span><span class="o">.</span><span class="n">find</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:hospital</span><span class="p">,</span>
</span><span class='line'>               <span class="ss">:lat</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="o">.</span><span class="n">lat</span><span class="p">,</span>
</span><span class='line'>               <span class="ss">:lon</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="o">.</span><span class="n">lon</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">locator</span> <span class="o">=</span> <span class="no">GeoFishAdapter</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">geo_fish_locator</span><span class="p">)</span>
</span><span class='line'><span class="n">find_nearest_hospital</span><span class="p">(</span><span class="n">locator</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>特意假设的例子就到此为止，接下来让我们看看真实的代码。</p>

<h3>MultiJSON</h3>

<p><code>ActiveSupport</code>在做JSON格式的解码时，用到的是<code>MultiJSON</code>，这是一个针对JSON库的适配器。每一个库都能够解析JSON，但是做法却不尽相同。让我们分别看看针对<a href="https://github.com/ohler55/oj">oj</a>和<a href="https://github.com/brianmario/yajl-ruby">yajl</a>的适配器。
(<strong>提示</strong>: 可在命令行中输入<code>qw multi_json</code>查看源码。)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">MultiJson</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Adapters</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Oj</span> <span class="o">&lt;</span> <span class="no">Adapter</span>
</span><span class='line'>      <span class="c1">#...</span>
</span><span class='line'>      <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
</span><span class='line'>        <span class="n">options</span><span class="o">[</span><span class="ss">:symbol_keys</span><span class="o">]</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:symbolize_keys</span><span class="p">)</span>
</span><span class='line'>        <span class="o">::</span><span class="no">Oj</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>      <span class="c1">#...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Oj的适配器修改了<code>options</code>哈希表，使用<code>Hash#delete</code>将<code>:symbolize_keys</code>项转换为Oj的<code>:symbol_keys</code>项：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:symbolize_keys</span> <span class="o">=&gt;</span> <span class="kp">true</span><span class="p">}</span>
</span><span class='line'><span class="n">options</span><span class="o">[</span><span class="ss">:symbol_keys</span><span class="o">]</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="ss">:symbolize_keys</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
</span><span class='line'><span class="n">options</span>                                                 <span class="c1"># =&gt; {:symbol_keys=&gt;true}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来MultiJSON调用了<code>::Oj.load(string, options)</code>。MultiJSON适配后的API跟Oj原有的API非常相似，在此不必赘述。不过你是否注意到，Oj是如何引用的呢？<code>::Oj</code>引用了顶层的<code>Oj</code>类，而不是<code>MultiJson::Adapters::Oj</code>。</p>

<p>现在让我们看看MultiJSON又是如何适配Yajl库的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">MultiJson</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Adapters</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Yajl</span> <span class="o">&lt;</span> <span class="no">Adapter</span>
</span><span class='line'>      <span class="c1">#...</span>
</span><span class='line'>      <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
</span><span class='line'>        <span class="o">::</span><span class="ss">Yajl</span><span class="p">:</span><span class="ss">:Parser</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:symbolize_keys</span> <span class="o">=&gt;</span> <span class="n">options</span><span class="o">[</span><span class="ss">:symbolize_keys</span><span class="o">]</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>      <span class="c1">#...</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个适配器从不同的方式实现了<code>load</code>方法。Yajl的方式是先创建一个解析器的实力，然后将传入的字符串<code>string</code>作为参数调用<code>Yajl::Parser#parse</code>方法。在<code>options</code>哈希表上的处理也略有不同。只有<code>:symbolize_keys</code>项被传递给了Yajl。</p>

<p>这些JSON的适配器看似微不足道，但是他们却可以让你随心所欲地在不同的库之间进行切换，而不需要在每一个解析JSON的地方更新代码。</p>

<h3>ActiveRecord</h3>

<p>很多JSON库往往都遵从相似的模式，这让适配工作变得相当轻松。但是如果你是在处理一些更加复杂的情况时，结果会是怎样？ActiveRecord包含了针对不同数据库的适配器。尽管PostgreSQL和MySQL都是SQL数据库，但是他们之间还是有很多不同之处，而ActiveRecord通过使用适配器模式屏蔽了这些不同。(<strong>提示</strong>: 命令行中输入<code>qw activerecord</code>查看ActiveRecord的代码)</p>

<p>打开ActiveRecord代码库中的<code>lib/connection_adapters</code>目录，里边会有针对PostgreSQL,MySQL以及SQLite的适配器。除此之外，还有一个名为<code>AbstractAdapter</code>的适配器，它作为每一个具体的适配器的基类。<code>AbstractAdapter</code>实现了在大部分数据库中常见的功能，这些功能在其子类比如<code>PostgreSQLAdapter</code>以及<code>AbstractMysqlAdapter</code>中被重新定制，而其中<code>AbstractMysqlAdapter</code>则是另外两个不同的MySQL适配器——MysqlAdapter以及Mysql2Adapter——的父类。让我们通过一些真实世界中的例子来看看他们是如何一起工作的。</p>

<p>PostgreSQL和MySQL在SQL方言的实现稍有不同。查询语句<code>SELECT * FROM users</code>在这两个数据库都可以正常执行，但是它们在一些类型的处理上会稍显不同。在MySQL和PostgreSQL中，时间格式就不尽相同。其中，PostgreSQL支持微秒级别的时间，而MySQL只是到了最近的一个稳定发布的版本中才支持。那这两个适配器又是如何处理这种差异的呢？</p>

<p>ActiveRecord通过被混入到<code>AbstractAdapter</code>的<code>ActiveRecord::ConnectionAdapters::Quoting</code>中的<code>quoted_date</code>引用日期。而<code>AbstractAdapter</code>中的实现仅仅只是格式化了日期：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">quoted_date</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>  <span class="c1">#...</span>
</span><span class='line'>  <span class="n">value</span><span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="ss">:db</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Rails中的ActiveSupport扩展了<code>Time#to_s</code>，使其能够接收一个代表格式名的符号类型参数。<code>:db</code>所代表的格式就是<code>%Y-%m-%d %H:%M:%S</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Examples of common formats:</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="ss">:db</span><span class="p">)</span>      <span class="c1">#=&gt; &quot;2014-02-19 06:08:13&quot;</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="ss">:short</span><span class="p">)</span>   <span class="c1">#=&gt; &quot;19 Feb 06:08&quot;</span>
</span><span class='line'><span class="no">Time</span><span class="o">.</span><span class="n">now</span><span class="o">.</span><span class="n">to_s</span><span class="p">(</span><span class="ss">:rfc822</span><span class="p">)</span>  <span class="c1">#=&gt; &quot;Wed, 19 Feb 2014 06:08:13 +0000&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>MySQL的适配器都没有重写<code>quoted_date</code>方法，它们自然会继承这种行为。另一边，<code>PostgreSQLAdapter</code>则对日期的处理做了两个修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">quoted_date</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>  <span class="n">result</span> <span class="o">=</span> <span class="k">super</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">acts_like?</span><span class="p">(</span><span class="ss">:time</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">value</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:usec</span><span class="p">)</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">result</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="nb">sprintf</span><span class="p">(</span><span class="s2">&quot;%06d&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">usec</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">year</span> <span class="o">&lt;</span> <span class="mi">0</span>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sr">/^-/</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; BC&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="n">result</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>它在一开始便调用<code>super</code>方法，所以它也会得到一个类似MySQL中格式化后的日期。接下来，它检测<code>value</code>是否像是一个具体时间。这是一个ActiveSupport中扩展的方法，当一个对象类似<code>Time</code>类型的实例时，它会返回<code>true</code>。这让它更容易表明各种对象已被假设为类似<code>Time</code>的对象。（<strong>提示</strong>: 对<code>acts_like?</code>方法感兴趣？请在命令行中执行<code>qw activesupport</code>，然后阅读<code>core_ext/object/acts_like.rb</code>）</p>

<p>第二部分的条件检查<code>value</code>是否有用于返回毫秒的<code>usec</code>方法。如果可以求得毫秒数，那么它将通过<code>sprintf</code>方法被追加到<code>result</code>字符串的末尾。跟很多时间格式一样，<code>sprintf</code>也有很多不同的方式用于格式化数字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">sprintf</span><span class="p">(</span><span class="s2">&quot;%06d&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="c1">#=&gt; &quot;000032&quot;</span>
</span><span class='line'><span class="nb">sprintf</span><span class="p">(</span><span class="s2">&quot;%6d&quot;</span><span class="p">,</span>  <span class="mi">32</span><span class="p">)</span> <span class="c1">#=&gt; &quot;    32&quot;</span>
</span><span class='line'><span class="nb">sprintf</span><span class="p">(</span><span class="s2">&quot;%d&quot;</span><span class="p">,</span>   <span class="mi">32</span><span class="p">)</span> <span class="c1">#=&gt; &quot;32&quot;</span>
</span><span class='line'><span class="nb">sprintf</span><span class="p">(</span><span class="s2">&quot;%.2f&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="c1">#=&gt; &quot;32.00&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，假如日期是一个负数，<code>PostgreSQLAdapter</code>就会通过加上&#8221;BC&#8221;去重新格式化日期，这是PostgreSQL数据库的实际要求：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SELECT</span> <span class="s1">&#39;2000-01-20&#39;</span><span class="o">::</span><span class="n">timestamp</span><span class="p">;</span>
</span><span class='line'><span class="o">--</span> <span class="mi">2000</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">20</span> <span class="mo">00</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span>
</span><span class='line'><span class="no">SELECT</span> <span class="s1">&#39;2000-01-20 BC&#39;</span><span class="o">::</span><span class="n">timestamp</span><span class="p">;</span>
</span><span class='line'><span class="o">--</span> <span class="mi">2000</span><span class="o">-</span><span class="mo">01</span><span class="o">-</span><span class="mi">20</span> <span class="mo">00</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mo">00</span> <span class="no">BC</span>
</span><span class='line'><span class="no">SELECT</span> <span class="s1">&#39;-2000-01-20&#39;</span><span class="o">::</span><span class="n">timestamp</span><span class="p">;</span>
</span><span class='line'><span class="o">--</span> <span class="ss">ERROR</span><span class="p">:</span>  <span class="n">time</span> <span class="n">zone</span> <span class="n">displacement</span> <span class="n">out</span> <span class="n">of</span> <span class="ss">range</span><span class="p">:</span> <span class="s2">&quot;-2000-01-20&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这只是ActiveRecord适配多个API时的一个极小的方式，但它却能帮助你免除由于不同数据库的细节所带来的差异和烦恼。</p>

<p>另一个体现SQL数据库的不同点是数据库表被创建的方式。MySQL以及PostgreSQL中对主键的处理各不相同：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># AbstractMysqlAdapter</span>
</span><span class='line'><span class="no">NATIVE_DATABASE_TYPES</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">:primary_key</span> <span class="o">=&gt;</span> <span class="s2">&quot;int(11) DEFAULT NULL auto_increment PRIMARY KEY&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">#...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># PostgreSQLAdapter</span>
</span><span class='line'><span class="no">NATIVE_DATABASE_TYPES</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">primary_key</span><span class="p">:</span> <span class="s2">&quot;serial primary key&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="c1">#...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两种适配器都能够明白ActiveRecord中的主键的表示方式，但是它们会在创建新表的时候将此翻译为不同的SQL语句。当你下次在编写一个migration或者执行一个查询的时候，思考一下ActiveRecord的适配器以及它们为你做的所有微小的事情。</p>

<h3>DateTime和Time</h3>

<p>当MultiJson以及ActiveRecord实现了传统的适配器的时候，Ruby的灵活性使得另一种解决方案成为可能。<code>DateTime</code>以及<code>Time</code>都用于表示时间，但是它们在内部的处理上是不同的。虽然有着这些细微的差异，但是它们所暴露出来的API却是极其类似的（<strong>提示</strong>：命令行中执行<code>qw activesupport</code>查看此处相关代码）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">t</span> <span class="o">=</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="n">day</span>     <span class="c1">#=&gt; 19         (Day of month)</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="n">wday</span>    <span class="c1">#=&gt; 3          (Day of week)</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="n">usec</span>    <span class="c1">#=&gt; 371552     (Microseconds)</span>
</span><span class='line'><span class="n">t</span><span class="o">.</span><span class="n">to_i</span>    <span class="c1">#=&gt; 1392871392 (Epoch secconds)</span>
</span><span class='line'>
</span><span class='line'><span class="n">d</span> <span class="o">=</span> <span class="no">DateTime</span><span class="o">.</span><span class="n">now</span>
</span><span class='line'><span class="n">d</span><span class="o">.</span><span class="n">day</span>     <span class="c1">#=&gt; 19         (Day of month)</span>
</span><span class='line'><span class="n">d</span><span class="o">.</span><span class="n">wday</span>    <span class="c1">#=&gt; 3          (Day of week)</span>
</span><span class='line'><span class="n">d</span><span class="o">.</span><span class="n">usec</span>    <span class="c1">#=&gt; NoMethodError: undefined method `usec&#39;</span>
</span><span class='line'><span class="n">d</span><span class="o">.</span><span class="n">to_i</span>    <span class="c1">#=&gt; NoMethodError: undefined method `to_i&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>ActiveSupport通过添加缺失的方法来直接修改<code>DateTime</code>和<code>Time</code>，进而抹平了两者之间的差异。从实例上看，这里就有一个例子演示了ActiveSupport如何定义<code>DateTime#to_i</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">DateTime</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">to_i</span>
</span><span class='line'>    <span class="n">seconds_since_unix_epoch</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">seconds_since_unix_epoch</span>
</span><span class='line'>    <span class="p">(</span><span class="n">jd</span> <span class="o">-</span> <span class="mi">2440588</span><span class="p">)</span> <span class="o">*</span> <span class="mi">86400</span> <span class="o">-</span> <span class="n">offset_in_seconds</span> <span class="o">+</span> <span class="n">seconds_since_midnight</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">offset_in_seconds</span>
</span><span class='line'>    <span class="p">(</span><span class="n">offset</span> <span class="o">*</span> <span class="mi">86400</span><span class="p">)</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">seconds_since_midnight</span>
</span><span class='line'>    <span class="n">sec</span> <span class="o">+</span> <span class="p">(</span><span class="n">min</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">hour</span> <span class="o">*</span> <span class="mi">3600</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>每一个用于支持的方法，<code>seconds_since_unix_epoch</code>，<code>offset_in_seconds</code>，以及<code>seconds_since_midnight</code>都使用或者扩展了<code>DateTime</code>中已经存在的API去定义与<code>Time</code>中匹配的方法。</p>

<p>假如说我们前面所看到的适配器是相对于被适配对象的外部适配器，那么我们现在所看到的这个就可以被称之为内部适配器。与外部适配器不同的是，这种方法受限于已有的API，并且可能导致一些麻烦的矛盾问题。举例来说，<code>DateTime</code>和<code>Time</code>在一些特殊的场景下就有可能出现不一样的行为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">datetime</span> <span class="o">==</span> <span class="n">time</span> <span class="c1">#=&gt; true</span>
</span><span class='line'><span class="n">datetime</span> <span class="o">+</span> <span class="mi">1</span>     <span class="c1">#=&gt; 2014-02-26 07:32:39</span>
</span><span class='line'><span class="n">time</span> <span class="o">+</span> <span class="mi">1</span>         <span class="c1">#=&gt; 2014-02-25 07:32:40</span>
</span></code></pre></td></tr></table></div></figure>


<p>当加上1的时候，<code>DateTime</code>加上了一天，而<code>Time</code>则是加上了一秒。当你需要使用它们的时候，你要记住ActiveSupport基于这些不同，提供了诸如<code>change</code>和<code>Duration</code>等保证一致行为的方法或类。</p>

<p>这是一个好的模式吗？它理所当然是方便的，但是如你刚才所见，你仍旧需要注意其中的一些不同之处。</p>

<h3>总结</h3>

<p>设计模式不是只有Java才需要的。Rails通过使用设计模式以提供用于JSON解析以及数据库维护的统一接口。由于Ruby的灵活性，类似<code>DateTime</code>以及<code>Time</code>这样的类可以被直接地修改而提供相似的接口。Rails的源码就是一个可以让你挖掘真实世界中不同设计模式实例的天堂。</p>

<p>在这次的实践中，我们同时也发掘了一些有趣的代码：</p>

<ul>
<li><code>hash[:foo] = hash.delete(:bar)</code>是一个用于重命名哈希表中某一项的巧妙方法。</li>
<li>调用<code>::ClassName</code>会调用顶层的类。</li>
<li>ActiveSupport为<code>Time</code>、<code>Date</code>以及其他的类添加了一个可选的代表格式的参数<code>format</code>。</li>
<li><code>sprintf</code>可以用于格式化数字。</li>
</ul>


<p>想要探索更多的知识？回去看看MultiJson是如何处理以及解析格式的。仔细阅读你在你的数据库中所使用到的ActiveRecord的适配器的代码。浏览ActiveSupport中用于xml适配器的<code>XmlMini</code>，它跟MultiJson中的JSON适配器是类似的。在这些里面还会有很多可以学习的。</p>

<p>喜欢这篇文章？<br>
<a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>“解读Rails”中的文章。</p>
</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-03-03T13:40:03+08:00" pubdate data-updated="true">Mar 3<span>rd</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/rails/'>rails</a>, <a class='category' href='/blog/categories/ruby/'>ruby</a>, <a class='category' href='/blog/categories/fan-yi/'>翻译</a>, <a class='category' href='/blog/categories/jie-du-rails/'>解读Rails</a>, <a class='category' href='/blog/categories/she-ji-mo-shi/'>设计模式</a>, <a class='category' href='/blog/categories/gua-pei-qi-mo-shi/'>适配器模式</a>


</div>
	
	<div class="comments"><a href="#disqus_thread">Comments</a></div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		<a class="addthis_button_tweet"></a>
		
		
		<a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2017

    Martin

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'martin-blog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://Martin91.github.io/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi/';
        var disqus_url = 'http://Martin91.github.io/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-50624776-1']);
		_gaq.push(['_setDomainName','github.io']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F6d4498d8e2d7328fffdb1539f0589a61' type='text/javascript'%3E%3C/script%3E"));
</script>
<script>
  window.fbAsyncInit = function() {
    FB.init({
      appId      : '781315158664022',
      xfbml      : true,
      version    : 'v2.4'
    });
  };

  (function(d, s, id){
     var js, fjs = d.getElementsByTagName(s)[0];
     if (d.getElementById(id)) {return;}
     js = d.createElement(s); js.id = id;
     js.src = "//connect.facebook.net/en_US/sdk.js";
     fjs.parentNode.insertBefore(js, fjs);
   }(document, 'script', 'facebook-jssdk'));
</script>

</body>
</html>